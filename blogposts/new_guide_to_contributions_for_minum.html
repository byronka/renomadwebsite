<!--#include virtual="header.html" -->
<div class="entry">
	<p class="content-header">
		New Guide to Contributions for Minum
	<p>
	<div class="date">September 8, 2024</div>

<p class="content-body">
I keep reading essays (see notes below) how simplicity should be favored over
complexity.  That microservices, Kubernetes, and even the use of separate
frontend applications (rather than using server-side rendering) are overkill
for most projects.  I agree - I think it is best to avoid undue complexity, to
keep things simple, given what I believe to be the best way to start.
</p>

<p class="content-body">
With those ideas as the guiding star, <a href="https://github.com/byronka/minum">Minum</a> began
development in December of 2021. Version 1.0.0 was released almost a
year ago, and the project has entered a state of stability.  The
primary focus remains making available a zero-dependency minimalist
web framework for developers of monolithic, server-side-rendered web
applications.  
</p>

<p class="content-body">
A <a
	href="https://github.com/byronka/minum/blob/master/CONTRIBUTING.md">guide
	on making contributions</a> was recently added to the project.
</p>
<p class="content-body">
if any of this piqued your interest.  I would certainly value the
insight of other practitioners.
</p>

<h4>
Notes:
</h4>

<p class="content-body">
These are essays arguing against the trends of unnecessary complexity that have
become the table stakes in the programming industry.  Each paragraph is a link
back to its source text.
</p>

<blockquote cite="https://renegadeotter.com/2023/09/10/death-by-a-thousand-microservices.html" class="excerpt">
<a href="https://renegadeotter.com/2023/09/10/death-by-a-thousand-microservices.html" style="text-decoration: none; color: inherit;">
	The audit revealed an interesting pattern, where many startups
	experienced a sort of collective imposter syndrome while building
	straight-forward, simple, performant systems. There is a stigma
	attached to not starting out with microservices on day one - no matter
	the problem. “Everyone is doing microservices, yet we have a single
	Django monolith maintained by just a few engineers, and a MySQL
	instance - what are we doing wrong?”. The answer is almost always
	“nothing”.
</a>
</blockquote>

<blockquote cite="https://mcfunley.com/choose-boring-technology">
<a href="https://mcfunley.com/choose-boring-technology" style="text-decoration: none; color: inherit;">
	It can be amazing how far a small set of technology choices
	can go. The answer to this question in practice is almost
	never “we can’t do it,” it’s usually just somewhere on the
	spectrum of “well, we could do it, but it would be too hard”
	[4]. If you think you can’t accomplish your goals with what
	you’ve got now, you are probably just not thinking creatively
	enough.
</a>
</blockquote>

<blockquote cite="https://www.teamten.com/lawrence/writings/java-for-everything.html">
<a href="https://www.teamten.com/lawrence/writings/java-for-everything.html" style="text-decoration: none; color: inherit;">
	StackOverflow uses ASP.NET. So you can complain all day about
	public static void main, but have fun setting up 500 servers.
	The downsides of dynamic languages are real, expensive, and
	permanent.
</a>
</blockquote>

<blockquote cite="https://riak.com/posts/technical/microservices-please-dont/">
<a href="https://riak.com/posts/technical/microservices-please-dont/" style="text-decoration: none; color: inherit;">
	Additionally, it also makes writing tests more difficult, as to write
	a proper set of integrations tests means understanding all of the
	different services a given interaction might invoke, capturing all of
	the possible error cases, etc etc. There is even more time spent on
	simply understanding the system, which could better be spent
	continuing to develop it. While I would never tell any engineer that
	time spent understanding a system is time wasted, I would definitely
	warn people away from prematurely adding these levels of complexity
	until they know they need it.
</a>
</blockquote>


<blockquote cite="https://www.timr.co/server-side-rendering-is-a-thiel-truth/">
<a href="https://www.timr.co/server-side-rendering-is-a-thiel-truth/" style="text-decoration: none; color: inherit;">
	People newer to the industry might never have built a server-side
	rendered app, so it's not an open question for them. As a result, for
	most client-side rendering is uncontroversially the 'right' way to
	build software.

	I think they're wrong: server-side rendering is more often the better
	choice.
</a>
</blockquote>


<blockquote cite="https://www.simplethread.com/gasp-you-might-not-need-microservices/">
<a href="https://www.simplethread.com/gasp-you-might-not-need-microservices/" style="text-decoration: none; color: inherit;">
	By adopting Microservices or micro-frontends, you’re shifting the
	complexity, not removing it. In some places the shift is worth it, but
	if your system isn’t large enough, your teams aren’t numerous enough,
	and the problems you’re facing aren’t coming from coordinating huge
	numbers of developers, then splitting your application up into lots of
	tiny pieces will likely create more headaches than it eliminates.
</a>
</blockquote>


<blockquote cite="https://web.archive.org/web/20170228054121/http://richardwellum.com/2017/02/simplify-then-add-lightness/">
<a href="https://web.archive.org/web/20170228054121/http://richardwellum.com/2017/02/simplify-then-add-lightness/" style="text-decoration: none; color: inherit;">
	Simple designs for a racing car offer a huge advantage over
	complicated rivals, because they are easier to maintain. A complicated
	design has more things that can go wrong, and when they do go wrong it
	is more difficult to design and fix. This should be painfully familiar
	to anyone working in software engineering, and yet as a whole we keep
	producing over-complicated solutions. 
</a>
</blockquote>

<blockquote cite="https://thenewstack.io/developers-rail-against-javascript-merchants-of-complexity/">
<a href="https://thenewstack.io/developers-rail-against-javascript-merchants-of-complexity/" style="text-decoration: none; color: inherit;">
	“I’m seeing a revival now,” said Levels, regarding PHP. “People are
	getting sick of frameworks. All the JavaScript frameworks are so… what
	do you call it, like [un]wieldy. It takes so much work to just
	maintain this code, and then it updates to a new version, you need to
	change everything. PHP just stays the same and works.”
</a>
</blockquote>


<blockquote cite="https://martinfowler.com/bliki/MonolithFirst.html">
<a href="https://martinfowler.com/bliki/MonolithFirst.html" style="text-decoration: none; color: inherit;">
	Microservices are a useful architecture, but even their
	advocates say that using them incurs a significant
	MicroservicePremium, which means they are only useful with
	more complex systems. This premium, essentially the cost of
	managing a suite of services, will slow down a team, favoring
	a monolith for simpler applications. This leads to a powerful
	argument for a monolith-first strategy, where you should build
	a new application as a monolith initially, even if you think
	it's likely that it will benefit from a microservices
	architecture later on.
</a>
</blockquote>

<!--#include virtual="footer.html" -->
